Strategy Pattern
================

### 특징

실행중에 알고리즘을 선택할수 있게 하는 행위(behavior) 소프트웨어 디자인 패턴

- 특정한 계열의 알고리즘 정의하고
- 각 알고리즘 캡슐화하며
- 이 알고리즘들을 해당 계열 안에서 상호 교체가 가능하게 만든다.

위에서 알고리즘 = 전략이다.

**전략**은 목적을 달성, 문제를 해결, 비즈니스 로직을 수행하는 알고리즘등을 말한다.

객체 지향의 관점에서 해석하면, 행위를 클래스로 캡슐화하여 *동적으로 행위를 자유롭게 바꿀수 있게* 해주는 패턴

> 같은 문제를 해결하는 여러 전략(알고리즘)이 클래스별로 캡슐화되어 있고,
>
> 전략(알고리즘)을 필요에 따라 교체할수 있도록 하여 동일한 문제를 다른 전략(알고리즘)으로 해결할수 있게 하는 디자인 패턴

**즉 전략을 쉽게 바꿀수 있도록 해주는 디자인 패턴**이다.

### 구조
![전략 패턴](../../../../../resources/image/strategy3.png)

### 예시

#### 문제상황 
>   어느날 가벼운 여행객을 위한 네비게이션 어플리케이션을 개발했다. 
이 어플리케이션은 아름다운 지도와 훌륭한 UI로 고객들이 어느도시든 쉽게 안내받도록 제작되었다.
> 
> 처음 어플리케이션은 빠르게 목적지에 도달하는것을 길안내 알고리즘의 목표로 잡았고, 차도 기준 안내를 했다.
> 
>어느날 도보 여행자와 대중교통 여행자를 위한 길안내 로직의 추가가 요청되었다. 따라서 새로운 로직을 위해 조건문등 기존 로직에 수정및 추가가 이뤄졌다.
> 
> 그 결과 나중에는 사소한 변경이 이전에 잘 동작하던 로직에도 버그를 유발하는 등의 유지보수에 어려움을 겪었다.
 

#### 해결 방안 
전략 패턴은 다양한 방식으로 특정 작업을 수행하는 클래스를 각각 **전략이라는 별도의 클래스**로 
추출하는 것에서 시작한다.

context라는 기존 클래스에는 전략 중 하나에 대한 **참조를 저장(의존성 주입)을 받기위한 필드**가 있어야 한다.
context는 **자체적으로 로직을 실행하는 것이 아니라 연결된 전략 객체에 작업의 수행을 위임**한다.

context가 직접적으로 전략을 선택하는 것이 아니라, 클라이언트가 원하는 전략을 context에 전달한다.
**context는 전략에 대해 알지 못하고** 단지 선택한 전략내에 캡슐화된 알고리즘을 수행하기 위해 인터페이스
로 제공되는 **전략 수행을 호출**하고, 각각의 로직은 해당 인터페이스를 구현하여 모두 **동일한 호출로 다르게 동작**한다.

이러한 방식으로 **context는 구체적 전략과 무관하게 설계**되었기 때문에 

_context 또는
기타 로직의 변경을 변경하지 않아도 새로운 전략을 추가하거나 기존 전략을 수정할수 있게 되었다._

![전략 패턴](../../../../../resources/image/strategy2.png) 

---------------------------------------------------------------- 
