Strategy Pattern
================

### 설명

실행중에 알고리즘을 선택할수 있게 하는 행위(behavior) 소프트웨어 디자인 패턴

- 특정한 계열의 알고리즘 정의하고
- 각 알고리즘 캡슐화하며
- 이 알고리즘들을 해당 계열 안에서 상호 교체가 가능하게 만든다.

위에서 알고리즘 = 전략이다.

**전략**은 목적을 달성, 문제를 해결, 비즈니스 로직을 수행하는 알고리즘등을 말한다.

객체 지향의 관점에서 해석하면, 행위를 클래스로 캡슐화하여 *동적으로 행위를 자유롭게 바꿀수 있게* 해주는 패턴

> 같은 문제를 해결하는 여러 전략(알고리즘)이 클래스별로 캡슐화되어 있고,
>
> 전략(알고리즘)을 필요에 따라 교체할수 있도록 하여 동일한 문제를 다른 전략(알고리즘)으로 해결할수 있게 하는 디자인 패턴

**즉 전략을 쉽게 바꿀수 있도록 해주는 디자인 패턴**이다.

### 특징

- 객체 내에서 다양한 알고리즘 변형을 사용하고 런타임 중 한 알고리즘에서 다른 알고리즘으로 전환할수 있도록 하려는 경우 사용
  - 런타임에 다른 방식으로 객체 동작을 간접적 변경이 가능하다.
  

- 일부 동작을 실행하는 방식만 다른 유사한 클래스가 많은 경우 사용
  - 다양한 동작을 별도의 클래스 계층으로 추출하고 기존 클래스를 하나로 결합하여 중복 코드를 줄일 수 있다.
  
- 로직의 콘텍스트에서 중요하지 않는 구현 세부 사항을 클래스의 비즈니스 로직에서 분리할 수 있다.
  - 코드의 나머지 부분에서 코드,내부 데이터 및 다양한 알고리즘의 종속성을 격리할 수 있다. 클라이언트는 알고리즘의 실행, 런타임 전환에 관한 인터페이스를 통해서 다양한 알고리즘을 수행할 수 있다. 

- 동일한 알고리즘의 다른 변형간 전환하는 조건문이 있는 경우 패턴 사용
  - 동일한 인터페이스를 구현하는 별도의 클래스로 추출하여, 조건을 제거할 수 있다. 모든 알고리즘의 변형을 구현하는 것이 아니라, 인터페이스를 상속받아 구현된 객체에 실행을 위임한다.

### 구현 방법
1. Context 클래스에서 자주 변경되기 쉬운 알고리즘 식별 (런타임에 조건을 통해 선택되는 알고리즘일 수 있다.)



2. 다양한 알고리즘에 공통된 전략 인터페이스 생성 


3. 전략 인터페이스를 구현하는 각각의 자체 클래스 객체로 추출


4. Context에서 전략 개체에 대한 참조를 저장하기 위한 필드 추가(ex : 스프링 injected field) + 해당 필드 값을 대체하기 위한 setter 제공. Cotext는 전략 인터페이스 호출을 통해 구현된 전략을 수행할 수 있다. 전략의 데이터 접근을 위해 파라미터 같은 방식으로 인터페이스에 데이터를 제공할 수 있다.


5. Context의 클라이언트는 인터페이스 호출을 통해 기대하는 방식과 일치하는 적절한 전략을 Context에 주입해 수행 


### 구조
![전략 패턴](../../../../../resources/image/strategy3.png)



### 예시

#### 문제상황 
>   어느날 가벼운 여행객을 위한 네비게이션 어플리케이션을 개발했다. 
이 어플리케이션은 아름다운 지도와 훌륭한 UI로 고객들이 어느도시든 쉽게 안내받도록 제작되었다.
> 
> 처음 어플리케이션은 빠르게 목적지에 도달하는것을 길안내 알고리즘의 목표로 잡았고, 차도 기준 안내를 했다.
> 
>어느날 도보 여행자와 대중교통 여행자를 위한 길안내 로직의 추가가 요청되었다. 따라서 새로운 로직을 위해 조건문등 기존 로직에 수정및 추가가 이뤄졌다.
> 
> 그 결과 나중에는 사소한 변경이 이전에 잘 동작하던 로직에도 버그를 유발하는 등의 유지보수에 어려움을 겪었다.
 

#### 해결 방안 
전략 패턴은 다양한 방식으로 특정 작업을 수행하는 클래스를 각각 **전략이라는 별도의 클래스**로 
추출하는 것에서 시작한다.

context라는 기존 클래스에는 전략 중 하나에 대한 **참조를 저장(의존성 주입)을 받기위한 필드**가 있어야 한다.
context는 **자체적으로 로직을 실행하는 것이 아니라 연결된 전략 객체에 작업의 수행을 위임**한다.

context가 직접적으로 전략을 선택하는 것이 아니라, 클라이언트가 원하는 전략을 context에 전달한다.
**context는 전략에 대해 알지 못하고** 단지 선택한 전략내에 캡슐화된 알고리즘을 수행하기 위해 인터페이스
로 제공되는 **전략 수행을 호출**하고, 각각의 로직은 해당 인터페이스를 구현하여 모두 **동일한 호출로 다르게 동작**한다.

이러한 방식으로 **context는 구체적 전략과 무관하게 설계**되었기 때문에 

_context 또는
기타 로직의 변경을 변경하지 않아도 새로운 전략을 추가하거나 기존 전략을 수정할수 있게 되었다._

![전략 패턴](../../../../../resources/image/strategy2.png) 

### 장/단점

#### 장점
- 런타임에 객체 내부에서 사용되는 알고리즘 변경 가능.
- 알고리즘 사용 코드(알고리즘을 호출하는 코드)에서 구체적 구현 내용을 분리 할 수 있다.
- 상속을 구현으로 대체 가능
- OCP( Context를 변경하지 않고 새로운 전략 도입 가능 )

#### 단점
- 알고리즘의 갯수가 적거나, 자주 변경되지 않는 경우 패턴의 구조와 방식으로 코드의 복잡도가 올라간다.
- 클라이언트가 적절한 전략을 선택할 수 있도록, 전략의 내용에 대해 알고 있어야한다.
- 함수형 프로그래밍 방식으로 심플하게 같은 효과를 거둘 수 있다.


#### 예시
- Java Comparator
- [Spring의 ApplicationContext](useCase/Spring/ApplicationContenxt.md)